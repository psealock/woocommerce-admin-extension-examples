{"version":3,"sources":["/Users/gziolo/PhpstormProjects/gutenberg/packages/babel-plugin-import-jsx-pragma/src/index.js"],"names":["DEFAULT_OPTIONS","scopeVariable","source","isDefault","babel","t","types","getOptions","state","_options","opts","visitor","JSXElement","path","hasJSX","ImportDeclaration","hasImportedScopeVariable","node","specifiers","some","specifier","type","imported","name","Program","exit","importDefaultSpecifier","identifier","importSpecifier","importDeclaration","stringLiteral","unshiftContainer"],"mappings":";;AAAA;;;;;;;;;;;;AAYA,IAAMA,eAAe,GAAG;AACvBC,EAAAA,aAAa,EAAE,OADQ;AAEvBC,EAAAA,MAAM,EAAE,OAFe;AAGvBC,EAAAA,SAAS,EAAE;AAHY,CAAxB;AAMA;;;;;;;;;;;AAUA,eAAe,UAAUC,KAAV,EAAkB;AAAA,MACjBC,CADiB,GACXD,KADW,CACxBE,KADwB;;AAGhC,WAASC,UAAT,CAAqBC,KAArB,EAA6B;AAC5B,QAAK,CAAEA,KAAK,CAACC,QAAb,EAAwB;AACvBD,MAAAA,KAAK,CAACC,QAAN,qBACIT,eADJ,EAEIQ,KAAK,CAACE,IAFV;AAIA;;AAED,WAAOF,KAAK,CAACC,QAAb;AACA;;AAED,SAAO;AACNE,IAAAA,OAAO,EAAE;AACRC,MAAAA,UADQ,sBACIC,IADJ,EACUL,KADV,EACkB;AACzBA,QAAAA,KAAK,CAACM,MAAN,GAAe,IAAf;AACA,OAHO;AAIRC,MAAAA,iBAJQ,6BAIWF,IAJX,EAIiBL,KAJjB,EAIyB;AAChC,YAAKA,KAAK,CAACQ,wBAAX,EAAsC;AACrC;AACA;;AAH+B,0BAKKT,UAAU,CAAEC,KAAF,CALf;AAAA,YAKxBP,aALwB,eAKxBA,aALwB;AAAA,YAKTE,SALS,eAKTA,SALS,EAOhC;AACA;AACA;AACA;;;AACAK,QAAAA,KAAK,CAACQ,wBAAN,GAAiCH,IAAI,CAACI,IAAL,CAAUC,UAAV,CAAqBC,IAArB,CAA2B,UAAEC,SAAF,EAAiB;AAC5E,kBAASA,SAAS,CAACC,IAAnB;AACC,iBAAK,iBAAL;AACC,qBACC,CAAElB,SAAF,IACAiB,SAAS,CAACE,QAAV,CAAmBC,IAAnB,KAA4BtB,aAF7B;;AAKD,iBAAK,wBAAL;AACC,qBAAOE,SAAP;AARF;AAUA,SAXgC,CAAjC;AAYA,OA3BO;AA4BRqB,MAAAA,OAAO,EAAE;AACRC,QAAAA,IADQ,gBACFZ,IADE,EACIL,KADJ,EACY;AACnB,cAAK,CAAEA,KAAK,CAACM,MAAR,IAAkBN,KAAK,CAACQ,wBAA7B,EAAwD;AACvD;AACA;;AAHkB,6BAK0BT,UAAU,CAAEC,KAAF,CALpC;AAAA,cAKXP,aALW,gBAKXA,aALW;AAAA,cAKIC,MALJ,gBAKIA,MALJ;AAAA,cAKYC,SALZ,gBAKYA,SALZ;;AAOnB,cAAIiB,SAAJ;;AACA,cAAKjB,SAAL,EAAiB;AAChBiB,YAAAA,SAAS,GAAGf,CAAC,CAACqB,sBAAF,CACXrB,CAAC,CAACsB,UAAF,CAAc1B,aAAd,CADW,CAAZ;AAGA,WAJD,MAIO;AACNmB,YAAAA,SAAS,GAAGf,CAAC,CAACuB,eAAF,CACXvB,CAAC,CAACsB,UAAF,CAAc1B,aAAd,CADW,EAEXI,CAAC,CAACsB,UAAF,CAAc1B,aAAd,CAFW,CAAZ;AAIA;;AAED,cAAM4B,iBAAiB,GAAGxB,CAAC,CAACwB,iBAAF,CACzB,CAAET,SAAF,CADyB,EAEzBf,CAAC,CAACyB,aAAF,CAAiB5B,MAAjB,CAFyB,CAA1B;AAKAW,UAAAA,IAAI,CAACkB,gBAAL,CAAuB,MAAvB,EAA+BF,iBAA/B;AACA;AA1BO;AA5BD;AADH,GAAP;AA2DA","sourcesContent":["/**\n * Default options for the plugin.\n *\n * @property {string}  scopeVariable Name of variable required to be in scope\n *                                   for use by the JSX pragma. For the default\n *                                   pragma of React.createElement, the React\n *                                   variable must be within scope.\n * @property {string}  source        The module from which the scope variable\n *                                   is to be imported when missing.\n * @property {boolean} isDefault     Whether the scopeVariable is the default\n *                                   import of the source module.\n */\nconst DEFAULT_OPTIONS = {\n\tscopeVariable: 'React',\n\tsource: 'react',\n\tisDefault: true,\n};\n\n/**\n * Babel transform plugin for automatically injecting an import to be used as\n * the pragma for the React JSX Transform plugin.\n *\n * @see http://babeljs.io/docs/en/babel-plugin-transform-react-jsx\n *\n * @param {Object} babel Babel instance.\n *\n * @return {Object} Babel transform plugin.\n */\nexport default function( babel ) {\n\tconst { types: t } = babel;\n\n\tfunction getOptions( state ) {\n\t\tif ( ! state._options ) {\n\t\t\tstate._options = {\n\t\t\t\t...DEFAULT_OPTIONS,\n\t\t\t\t...state.opts,\n\t\t\t};\n\t\t}\n\n\t\treturn state._options;\n\t}\n\n\treturn {\n\t\tvisitor: {\n\t\t\tJSXElement( path, state ) {\n\t\t\t\tstate.hasJSX = true;\n\t\t\t},\n\t\t\tImportDeclaration( path, state ) {\n\t\t\t\tif ( state.hasImportedScopeVariable ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { scopeVariable, isDefault } = getOptions( state );\n\n\t\t\t\t// Test that at least one import specifier exists matching the\n\t\t\t\t// scope variable name. The module source is not verified since\n\t\t\t\t// we must avoid introducing a conflicting import name, even if\n\t\t\t\t// the scope variable is referenced from a different source.\n\t\t\t\tstate.hasImportedScopeVariable = path.node.specifiers.some( ( specifier ) => {\n\t\t\t\t\tswitch ( specifier.type ) {\n\t\t\t\t\t\tcase 'ImportSpecifier':\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t! isDefault &&\n\t\t\t\t\t\t\t\tspecifier.imported.name === scopeVariable\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\tcase 'ImportDefaultSpecifier':\n\t\t\t\t\t\t\treturn isDefault;\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t},\n\t\t\tProgram: {\n\t\t\t\texit( path, state ) {\n\t\t\t\t\tif ( ! state.hasJSX || state.hasImportedScopeVariable ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { scopeVariable, source, isDefault } = getOptions( state );\n\n\t\t\t\t\tlet specifier;\n\t\t\t\t\tif ( isDefault ) {\n\t\t\t\t\t\tspecifier = t.importDefaultSpecifier(\n\t\t\t\t\t\t\tt.identifier( scopeVariable )\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tspecifier = t.importSpecifier(\n\t\t\t\t\t\t\tt.identifier( scopeVariable ),\n\t\t\t\t\t\t\tt.identifier( scopeVariable )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst importDeclaration = t.importDeclaration(\n\t\t\t\t\t\t[ specifier ],\n\t\t\t\t\t\tt.stringLiteral( source )\n\t\t\t\t\t);\n\n\t\t\t\t\tpath.unshiftContainer( 'body', importDeclaration );\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t};\n}\n"]}